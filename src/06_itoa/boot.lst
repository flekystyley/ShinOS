     1                                  ;---------------------
     2                                  ; - Configration Start to Boot Program Address.
     3                                  ;---------------------
     4                                  BOOT_LOAD equ 0x7c00    ; load to start boot program address.
     5                                  ORG BOOT_LOAD           ; instruction load address to assembler.
     6                                  
     7                                  ;---------------------
     8                                  ; - Declaration Macro.
     9                                  ;---------------------
    10                                  %include "../include/macro.asm"
     1                              <1> %macro cdecl 1-*nolist
     2                              <1> 
     3                              <1>     %rep %0 - 1
     4                              <1>         push %{-1:-1}
     5                              <1>         %rotate -1
     6                              <1>     %endrep
     7                              <1>     %rotate -1
     8                              <1> 
     9                              <1>         call %1
    10                              <1>     
    11                              <1>     %if 1 < %0
    12                              <1>         add sp, (__BITS__ >> 3) * (%0-1)
    13                              <1>     %endif
    14                              <1>     
    15                              <1> %endmacro
    11                                  
    12                                  entry:
    13                                      ;---------------------
    14                                      ; - BPB(BIOS Parameter Block).
    15                                      ; - First calling to ipl label.
    16                                      ; - BIOS Needs Information.
    17                                      ; - 0x90 set to 90bytes.
    18                                      ; - NOP(do no something).
    19                                      ;---------------------
    20 00000000 EB58                        jmp ipl
    21 00000002 90<rept>                    times 90 - ($ - $$) db 0x90
    22                                  
    23                                  ipl:
    24 0000005A FA                          cli                 ; disable interrupt.
    25                                  
    26                                      ;-------------------
    27                                      ; - Configuration Segment Register.
    28                                      ; - Segment is separate memory blocks.
    29                                      ; - Initialize Register.
    30                                      ;-------------------
    31 0000005B B80000                      mov ax, 0x0000      ; AX = 0x0000;
    32                                  
    33 0000005E 8ED8                        mov ds, ax          ; DS = 0x0000;
    34 00000060 8EC0                        mov es, ax          ; ES = 0x0000;
    35 00000062 8ED0                        mov ss, ax          ; SS = 0x0000;
    36                                  
    37                                      ;---------------------
    38                                      ; - Stack the boot program start position on the stack pointer.
    39                                      ;---------------------
    40 00000064 BC007C                      mov sp, BOOT_LOAD    ; SP = 0x7c00;
    41                                  
    42 00000067 FB                          sti                 ; enable interrupt.
    43                                  
    44                                      ;---------------------
    45                                      ; - Saving Boot Drive.
    46                                      ; - dl register is I/O register. 
    47                                      ;---------------------
    48 00000068 8816[4801]                  mov [BOOT.DRIVE], dl 
    49                                  
    50                                      ;--------------------
    51                                      ; - Call putc function, argument is '.s0'.
    52                                      ;--------------------
    53                                      cdecl putc, .s0
    53                              <1> 
    53                              <1>  %rep %0 - 1
    53                              <1>  push %-1:-1
    53                              <1>  %rotate -1
    53                              <1>  %endrep
    53 0000006C 68[3001]            <2>  push %-1:-1
    53                              <2>  %rotate -1
    53                              <1>  %rotate -1
    53                              <1> 
    53 0000006F E8D800              <1>  call %1
    53                              <1> 
    53                              <1>  %if 1 < %0
    53 00000072 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    53                              <1>  %endif
    53                              <1> 
    54                                  
    55                                      ;--------------------
    56                                      ; - Call itoa function, argument is '.s0'.
    57                                      ;--------------------
    58                                      ; cdecl itoa, 8086, .s1, 8, 10, 0b0001; "8086"
    59                                      ; cdecl putc, .s1
    60                                  
    61                                  	cdecl	itoa,  8086, .s1, 8, 10, 0b0001	; "    8086"
    61                              <1> 
    61                              <1>  %rep %0 - 1
    61                              <1>  push %-1:-1
    61                              <1>  %rotate -1
    61                              <1>  %endrep
    61 00000075 6A01                <2>  push %-1:-1
    61                              <2>  %rotate -1
    61 00000077 6A0A                <2>  push %-1:-1
    61                              <2>  %rotate -1
    61 00000079 6A08                <2>  push %-1:-1
    61                              <2>  %rotate -1
    61 0000007B 68[3D01]            <2>  push %-1:-1
    61                              <2>  %rotate -1
    61 0000007E 68961F              <2>  push %-1:-1
    61                              <2>  %rotate -1
    61                              <1>  %rotate -1
    61                              <1> 
    61 00000081 E8E500              <1>  call %1
    61                              <1> 
    61                              <1>  %if 1 < %0
    61 00000084 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    61                              <1>  %endif
    61                              <1> 
    62                                  	cdecl	putc, .s1
    62                              <1> 
    62                              <1>  %rep %0 - 1
    62                              <1>  push %-1:-1
    62                              <1>  %rotate -1
    62                              <1>  %endrep
    62 00000087 68[3D01]            <2>  push %-1:-1
    62                              <2>  %rotate -1
    62                              <1>  %rotate -1
    62                              <1> 
    62 0000008A E8BD00              <1>  call %1
    62                              <1> 
    62                              <1>  %if 1 < %0
    62 0000008D 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    62                              <1>  %endif
    62                              <1> 
    63                                  	cdecl	itoa,  8086, .s1, 8, 10, 0b0011	; "+   8086"
    63                              <1> 
    63                              <1>  %rep %0 - 1
    63                              <1>  push %-1:-1
    63                              <1>  %rotate -1
    63                              <1>  %endrep
    63 00000090 6A03                <2>  push %-1:-1
    63                              <2>  %rotate -1
    63 00000092 6A0A                <2>  push %-1:-1
    63                              <2>  %rotate -1
    63 00000094 6A08                <2>  push %-1:-1
    63                              <2>  %rotate -1
    63 00000096 68[3D01]            <2>  push %-1:-1
    63                              <2>  %rotate -1
    63 00000099 68961F              <2>  push %-1:-1
    63                              <2>  %rotate -1
    63                              <1>  %rotate -1
    63                              <1> 
    63 0000009C E8CA00              <1>  call %1
    63                              <1> 
    63                              <1>  %if 1 < %0
    63 0000009F 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    63                              <1>  %endif
    63                              <1> 
    64                                  	cdecl	putc, .s1
    64                              <1> 
    64                              <1>  %rep %0 - 1
    64                              <1>  push %-1:-1
    64                              <1>  %rotate -1
    64                              <1>  %endrep
    64 000000A2 68[3D01]            <2>  push %-1:-1
    64                              <2>  %rotate -1
    64                              <1>  %rotate -1
    64                              <1> 
    64 000000A5 E8A200              <1>  call %1
    64                              <1> 
    64                              <1>  %if 1 < %0
    64 000000A8 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    64                              <1>  %endif
    64                              <1> 
    65                                  	cdecl	itoa, -8086, .s1, 8, 10, 0b0001	; "-   8086"
    65                              <1> 
    65                              <1>  %rep %0 - 1
    65                              <1>  push %-1:-1
    65                              <1>  %rotate -1
    65                              <1>  %endrep
    65 000000AB 6A01                <2>  push %-1:-1
    65                              <2>  %rotate -1
    65 000000AD 6A0A                <2>  push %-1:-1
    65                              <2>  %rotate -1
    65 000000AF 6A08                <2>  push %-1:-1
    65                              <2>  %rotate -1
    65 000000B1 68[3D01]            <2>  push %-1:-1
    65                              <2>  %rotate -1
    65 000000B4 686AE0              <2>  push %-1:-1
    65                              <2>  %rotate -1
    65                              <1>  %rotate -1
    65                              <1> 
    65 000000B7 E8AF00              <1>  call %1
    65                              <1> 
    65                              <1>  %if 1 < %0
    65 000000BA 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    65                              <1>  %endif
    65                              <1> 
    66                                  	cdecl	putc, .s1
    66                              <1> 
    66                              <1>  %rep %0 - 1
    66                              <1>  push %-1:-1
    66                              <1>  %rotate -1
    66                              <1>  %endrep
    66 000000BD 68[3D01]            <2>  push %-1:-1
    66                              <2>  %rotate -1
    66                              <1>  %rotate -1
    66                              <1> 
    66 000000C0 E88700              <1>  call %1
    66                              <1> 
    66                              <1>  %if 1 < %0
    66 000000C3 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    66                              <1>  %endif
    66                              <1> 
    67                                  	cdecl	itoa,    -1, .s1, 8, 10, 0b0001	; "-      1"
    67                              <1> 
    67                              <1>  %rep %0 - 1
    67                              <1>  push %-1:-1
    67                              <1>  %rotate -1
    67                              <1>  %endrep
    67 000000C6 6A01                <2>  push %-1:-1
    67                              <2>  %rotate -1
    67 000000C8 6A0A                <2>  push %-1:-1
    67                              <2>  %rotate -1
    67 000000CA 6A08                <2>  push %-1:-1
    67                              <2>  %rotate -1
    67 000000CC 68[3D01]            <2>  push %-1:-1
    67                              <2>  %rotate -1
    67 000000CF 6AFF                <2>  push %-1:-1
    67                              <2>  %rotate -1
    67                              <1>  %rotate -1
    67                              <1> 
    67 000000D1 E89500              <1>  call %1
    67                              <1> 
    67                              <1>  %if 1 < %0
    67 000000D4 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    67                              <1>  %endif
    67                              <1> 
    68                                  	cdecl	putc, .s1
    68                              <1> 
    68                              <1>  %rep %0 - 1
    68                              <1>  push %-1:-1
    68                              <1>  %rotate -1
    68                              <1>  %endrep
    68 000000D7 68[3D01]            <2>  push %-1:-1
    68                              <2>  %rotate -1
    68                              <1>  %rotate -1
    68                              <1> 
    68 000000DA E86D00              <1>  call %1
    68                              <1> 
    68                              <1>  %if 1 < %0
    68 000000DD 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    68                              <1>  %endif
    68                              <1> 
    69                                  	cdecl	itoa,    -1, .s1, 8, 10, 0b0000	; "   65535"
    69                              <1> 
    69                              <1>  %rep %0 - 1
    69                              <1>  push %-1:-1
    69                              <1>  %rotate -1
    69                              <1>  %endrep
    69 000000E0 6A00                <2>  push %-1:-1
    69                              <2>  %rotate -1
    69 000000E2 6A0A                <2>  push %-1:-1
    69                              <2>  %rotate -1
    69 000000E4 6A08                <2>  push %-1:-1
    69                              <2>  %rotate -1
    69 000000E6 68[3D01]            <2>  push %-1:-1
    69                              <2>  %rotate -1
    69 000000E9 6AFF                <2>  push %-1:-1
    69                              <2>  %rotate -1
    69                              <1>  %rotate -1
    69                              <1> 
    69 000000EB E87B00              <1>  call %1
    69                              <1> 
    69                              <1>  %if 1 < %0
    69 000000EE 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    69                              <1>  %endif
    69                              <1> 
    70                                  	cdecl	putc, .s1
    70                              <1> 
    70                              <1>  %rep %0 - 1
    70                              <1>  push %-1:-1
    70                              <1>  %rotate -1
    70                              <1>  %endrep
    70 000000F1 68[3D01]            <2>  push %-1:-1
    70                              <2>  %rotate -1
    70                              <1>  %rotate -1
    70                              <1> 
    70 000000F4 E85300              <1>  call %1
    70                              <1> 
    70                              <1>  %if 1 < %0
    70 000000F7 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    70                              <1>  %endif
    70                              <1> 
    71                                  	cdecl	itoa,    -1, .s1, 8, 16, 0b0000	; "    FFFF"
    71                              <1> 
    71                              <1>  %rep %0 - 1
    71                              <1>  push %-1:-1
    71                              <1>  %rotate -1
    71                              <1>  %endrep
    71 000000FA 6A00                <2>  push %-1:-1
    71                              <2>  %rotate -1
    71 000000FC 6A10                <2>  push %-1:-1
    71                              <2>  %rotate -1
    71 000000FE 6A08                <2>  push %-1:-1
    71                              <2>  %rotate -1
    71 00000100 68[3D01]            <2>  push %-1:-1
    71                              <2>  %rotate -1
    71 00000103 6AFF                <2>  push %-1:-1
    71                              <2>  %rotate -1
    71                              <1>  %rotate -1
    71                              <1> 
    71 00000105 E86100              <1>  call %1
    71                              <1> 
    71                              <1>  %if 1 < %0
    71 00000108 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    71                              <1>  %endif
    71                              <1> 
    72                                  	cdecl	putc, .s1
    72                              <1> 
    72                              <1>  %rep %0 - 1
    72                              <1>  push %-1:-1
    72                              <1>  %rotate -1
    72                              <1>  %endrep
    72 0000010B 68[3D01]            <2>  push %-1:-1
    72                              <2>  %rotate -1
    72                              <1>  %rotate -1
    72                              <1> 
    72 0000010E E83900              <1>  call %1
    72                              <1> 
    72                              <1>  %if 1 < %0
    72 00000111 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    72                              <1>  %endif
    72                              <1> 
    73                                  	cdecl	itoa,    12, .s1, 8,  2, 0b0100	; "00001100"
    73                              <1> 
    73                              <1>  %rep %0 - 1
    73                              <1>  push %-1:-1
    73                              <1>  %rotate -1
    73                              <1>  %endrep
    73 00000114 6A04                <2>  push %-1:-1
    73                              <2>  %rotate -1
    73 00000116 6A02                <2>  push %-1:-1
    73                              <2>  %rotate -1
    73 00000118 6A08                <2>  push %-1:-1
    73                              <2>  %rotate -1
    73 0000011A 68[3D01]            <2>  push %-1:-1
    73                              <2>  %rotate -1
    73 0000011D 6A0C                <2>  push %-1:-1
    73                              <2>  %rotate -1
    73                              <1>  %rotate -1
    73                              <1> 
    73 0000011F E84700              <1>  call %1
    73                              <1> 
    73                              <1>  %if 1 < %0
    73 00000122 83C40A              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    73                              <1>  %endif
    73                              <1> 
    74                                  	cdecl	putc, .s1
    74                              <1> 
    74                              <1>  %rep %0 - 1
    74                              <1>  push %-1:-1
    74                              <1>  %rotate -1
    74                              <1>  %endrep
    74 00000125 68[3D01]            <2>  push %-1:-1
    74                              <2>  %rotate -1
    74                              <1>  %rotate -1
    74                              <1> 
    74 00000128 E81F00              <1>  call %1
    74                              <1> 
    74                              <1>  %if 1 < %0
    74 0000012B 83C402              <1>  add sp, (__BITS__ >> 3) * (%0-1)
    74                              <1>  %endif
    74                              <1> 
    75                                  
    76                                      ;--------------------
    77                                      ; - Terminate imp Proccess;
    78                                      ;--------------------    
    79 0000012E EBFE                        jmp $               ; Infinite loop.
    80                                  
    81                                  ;--------------------
    82                                  ; - 0x0A is LF(Line Feed).
    83                                  ; - 0x0D is CR(Caridge Return).
    84                                  ;--------------------
    85 00000130 426F6F74696E672E2E-     .s0 db "Booting...", 0x0A, 0x0D, 0
    85 00000139 2E0A0D00           
    86 0000013D 2D2D2D2D2D2D2D2D0A-     .s1 db "--------", 0x0A, 0x0D, 0
    86 00000146 0D00               
    87                                  ; .s1		db	"--------", 0x0A, 0x0D, 0
    88                                  
    89                                  ;--------------------
    90                                  ; - Place every 2 bytes.
    91                                  ;--------------------
    92                                  ALIGN 2, db 0
    93                                  BOOT:
    94 00000148 0000                    .DRIVE  dw 0            ; drive number.
    95                                  
    96                                  ;--------------------
    97                                  ; - Declaration Module.
    98                                  ;--------------------
    99                                  %include "../modules/real_mode/putc.asm"
     1                              <1> putc:
     2                              <1>     ;---------------------
     3                              <1>     ; Create Stack Frame.
     4                              <1>     ;---------------------
     5 0000014A 55                  <1>     push bp          ; push to stack base pointer register.
     6 0000014B 89E5                <1>     mov  bp, sp      ; bp = sp. set top stack.
     7                              <1> 
     8                              <1>     ;---------------------
     9                              <1>     ; Saving Register.
    10                              <1>     ;---------------------
    11 0000014D 50                  <1>     push ax         ; ax (ah, al)
    12 0000014E 53                  <1>     push bx         ; bx
    13 0000014F 56                  <1>     push si         ; si
    14                              <1> 
    15                              <1>     ;---------------------
    16                              <1>     ; Get func argument.
    17                              <1>     ;---------------------
    18 00000150 8B7604              <1>     mov si, [bp+4]
    19                              <1> 
    20                              <1>     ;---------------------
    21                              <1>     ; Starting put process.
    22                              <1>     ;---------------------
    23 00000153 B40E                <1>     mov ah, 0x0E    ; show Character output.
    24 00000155 BB0000              <1>     mov bx, 0x0000  ; set page number & text color to 0
    25 00000158 FC                  <1>     cld             ; DF = 0.
    26                              <1> 
    27                              <1> .10L:               ; do
    28                              <1>                     ; {
    29 00000159 AC                  <1>     lodsb           ; AL = *SI++.
    30                              <1>                     ;
    31 0000015A 3C00                <1>     cmp al, 0       ; if(0 == AL)
    32 0000015C 7404                <1>     je .10E         ; break
    33                              <1>                     ;
    34 0000015E CD10                <1>     int 0x10        ; Int10(0x0E, AL); prrint char.
    35 00000160 EBF7                <1>     jmp .10L        ;
    36                              <1> .10E:               ; while(1)
    37                              <1> 
    38                              <1>     ;---------------------
    39                              <1>     ; return Register.
    40                              <1>     ;---------------------    
    41 00000162 5E                  <1>     pop si
    42 00000163 5B                  <1>     pop bx
    43 00000164 58                  <1>     pop ax
    44                              <1> 
    45                              <1>     ;---------------------
    46                              <1>     ; reset Stack frame.
    47                              <1>     ;---------------------
    48 00000165 89EC                <1>     mov sp, bp
    49 00000167 5D                  <1>     pop bp
    50 00000168 C3                  <1>     ret
   100                                  %include "../modules/real_mode/itoa.asm"
     1                              <1> ;---------------------
     2                              <1> ; - Variable display function.
     3                              <1> ;---------------------
     4                              <1> itoa:
     5                              <1>     ;---------------------
     6                              <1>     ; - Create Stack Frame.
     7                              <1>     ;---------------------
     8                              <1>                           ; +12 | flag.
     9                              <1>                           ; +10 | base.
    10                              <1>                           ; +8  | buffer size.
    11                              <1>                           ; +6  | buffer address.
    12                              <1>                           ; +4  | numeric.
    13                              <1>                           ; +2  | return value.
    14                              <1>                           ; +0  | base value.
    15 00000169 55                  <1>     push bp
    16 0000016A 89E5                <1>     mov  bp, sp
    17                              <1> 
    18                              <1>     ;---------------------
    19                              <1>     ; - Saving Register.
    20                              <1>     ;---------------------
    21 0000016C 50                  <1>     push ax               ; ax(ax, al)
    22 0000016D 53                  <1>     push bx               ; bx is 
    23 0000016E 51                  <1>     push cx               ; cx is counter register.
    24 0000016F 52                  <1>     push dx               ; dx
    25 00000170 56                  <1>     push si               ; si is source index.
    26 00000171 57                  <1>     push di               ; di is destination index.
    27                              <1> 
    28                              <1>     ;---------------------
    29                              <1>     ; - Get argments.
    30                              <1>     ;---------------------
    31 00000172 8B4604              <1>     mov ax, [bp+4]             ; numeric.
    32 00000175 8B7606              <1>     mov si, [bp+6]             ; buffer address.
    33 00000178 8B4E08              <1>     mov cx, [bp+8]             ; buffer size.
    34                              <1>          
    35 0000017B 89F7                <1>     mov di, si                 ; di = &si. (si is source pointer.)
    36 0000017D 01CF                <1>     add di, cx                 ; di = &di[cx -1]
    37 0000017F 4F                  <1>     dec di                     ; decrement di.
    38                              <1>          
    39 00000180 8B5E0C              <1>     mov bx, [bp+12]       ; flags = options arg.
    40                              <1>     
    41                              <1>     ;---------------------
    42                              <1>     ; - Signed handling.
    43                              <1>     ;---------------------
    44 00000183 F7C30100            <1>     test bx, 0b0001            ; if(flags & 0x01), (test is 論理積)
    45 00000187 7408                <1> .10Q: je .10E                  ; { je is break (bx == 0)
    46 00000189 83F800              <1>     cmp ax, 0                  ; if (val < 0)
    47 0000018C 7D03                <1> .12Q: jge .12E                 ; { (0より小さい場合)
    48 0000018E 83CB02              <1>     or bx, 0b0010              ; bx = 2; 符号表示をさせるようにする
    49                              <1> .12E:                          ; }
    50                              <1> .10E:                          ; }
    51                              <1> 
    52                              <1>     ;---------------------
    53                              <1>     ; - Sign output judgment.
    54                              <1>     ;---------------------
    55 00000191 F7C30200            <1>     test bx, 0b0010            ; if(flags & 0x02)
    56 00000195 7410                <1> .20Q: je .20E                  ; {
    57 00000197 83F800              <1>     cmp ax, 0                  ; if(val < 0)
    58 0000019A 7D07                <1> .22Q: jge .22F                 ; {
    59 0000019C F7D8                <1>     neg ax                     ;     val *=-1; // 符号反転
    60 0000019E C6042D              <1>     mov [si], byte '-'         ;     dst ='-'  // 符号表示
    61 000001A1 EB03                <1>     jmp .22E                   ; }
    62                              <1> .22F:                          ; else
    63                              <1>                                ; {
    64 000001A3 C6042B              <1>     mov [si], byte '+'         ; *dst = '+';
    65                              <1> .22E:                          ; }
    66 000001A6 49                  <1>     dec cx                     ; size --; // 残りバッファサイズの計算
    67                              <1> .20E:                          ; }
    68                              <1> 
    69                              <1>     ;---------------------
    70                              <1>     ; - translate ascii.
    71                              <1>     ;---------------------
    72 000001A7 8B5E0A              <1>     mov bx, [bp+10]            ; bx = 基数 (2 or 8 or 16)
    73                              <1> .30L:                          ; do
    74                              <1>                                ; {
    75 000001AA BA0000              <1>     mov dx, 0                  ; dx = 0
    76                              <1> 
    77 000001AD F7F3                <1>     div bx                     ; DX = DX:AX % 基数 // 余
    78                              <1>                                ; 算術レジスタに格納される.                             
    79                              <1>                                ; AX = DX:AX / 基数 // 商
    80 000001AF 89D6                <1>     mov si, dx                 ; si = dx
    81 000001B1 8A94[D901]          <1>     mov dl, byte [.ascii + si] ; DL = ASCII[DX] Dx is 余. 余をindexとしてつかう.
    82                              <1>   
    83 000001B5 8815                <1>     mov [di], dl               ; *dst = DL. 文字列の代入
    84 000001B7 4F                  <1>     dec di                     ; dst--;
    85                              <1>          
    86 000001B8 83F800              <1>     cmp ax, 0                  ; (ax == 0) or (ax == 0)
    87 000001BB E0ED                <1>     loopnz .30L                ; } while (AX);
    88                              <1> .30E:
    89                              <1> 
    90                              <1>     ;---------------------  
    91                              <1>     ; - Remove space.  
    92                              <1>     ;---------------------
    93 000001BD 83F900              <1>     cmp cx, 0                  ; if(cx==0) cxのバッファサイズが０でなければ、空白を埋める.
    94 000001C0 740D                <1> .40Q: je .40E                  ; {
    95 000001C2 B020                <1>     mov al, ' '                 ; AL = ''; ''で埋める
    96 000001C4 837E0C04            <1>     cmp [bp+12], word 0b0100   ; if(flags & 0x04)
    97 000001C8 7502                <1> .42Q: jne .42E                 ; {
    98 000001CA B030                <1>     mov al, '0'                ; AL=0
    99                              <1> .42E:                          ; }
   100 000001CC FD                  <1>     std                        ; DF = 1 (-方向)
   101                              <1>                                ; ストリームの方向を逆にする
   102                              <1>                                ; カウンタレジスタ分文字列の空白を削除する
   103 000001CD F3AA                <1>     rep stosb                  ; while(--CX) *DI-- = '';
   104                              <1> .40E:                          ; }
   105                              <1>       
   106                              <1>     ;---------------------  
   107                              <1>     ; - Return Register.  
   108                              <1>     ;---------------------
   109 000001CF 5F                  <1>     pop di
   110 000001D0 5E                  <1>     pop si
   111 000001D1 5A                  <1>     pop dx
   112 000001D2 59                  <1>     pop cx
   113 000001D3 5B                  <1>     pop bx
   114 000001D4 58                  <1>     pop ax
   115                              <1> 
   116                              <1>     ;---------------------
   117                              <1>     ; - Remove Stack Frame.
   118                              <1>     ;---------------------
   119                              <1> 
   120 000001D5 89EC                <1>     mov sp, bp
   121 000001D7 5D                  <1>     pop bp
   122 000001D8 C3                  <1>     ret
   123                              <1> 
   124 000001D9 303132333435363738- <1> .ascii db "0123456789ABCDEF"   ; transfer table.
   124 000001E2 39414243444546      <1>
   101                                  
   102                                  ;--------------------
   103                                  ; - Boot Flag.
   104                                  ; - Maybe Reserve the first 512 bytes.
   105                                  ; - Write 0x55 and 0xAA to 510bytes.
   106                                  ;--------------------
   107 000001E9 00<rept>                times 510 - ($ - $$) db 0x00
   108 000001FE 55AA                    db 0x55, 0xAA
